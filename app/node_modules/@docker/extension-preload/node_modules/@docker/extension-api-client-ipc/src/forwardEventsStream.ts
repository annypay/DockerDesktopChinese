import type { ExecStreamOptions } from '@docker/extension-api-client-types/src/v1';
import { StreamBuffer } from './StreamBuffer';

export function forwardEventsStream(
  recv: MessagePort,
  streamOpts: ExecStreamOptions,
) {
  const stdoutBufer = new StreamBuffer();
  const stderrrBuffer = new StreamBuffer();
  // eslint-disable-next-line no-param-reassign
  recv.onmessage = ({ data }) => {
    if (streamOpts.onOutput) {
      if (data.stdout) {
        if (streamOpts.splitOutputLines) {
          const lines = stdoutBufer.onData(stingFromChunk(data.stdout));
          lines.forEach((l: string) => {
            streamOpts.onOutput?.({ stdout: l });
          });
        } else {
          streamOpts.onOutput({ stdout: stingFromChunk(data.stdout) });
        }
      }
      if (data.stderr) {
        if (streamOpts.splitOutputLines) {
          const lines = stderrrBuffer.onData(stingFromChunk(data.stderr));
          lines.forEach((l: string) => {
            streamOpts.onOutput?.({ stderr: l });
          });
        } else {
          streamOpts.onOutput({ stderr: stingFromChunk(data.stderr) });
        }
      }
    }

    if (data.close && streamOpts.onClose) {
      streamOpts.onClose(data.code);
    }
  };

  function stingFromChunk(chunk: any): string {
    return String.fromCharCode.apply(
      null,
      // @ts-ignore hush typescript, everything is fine
      new Uint16Array(chunk),
    );
  }

  // eslint-disable-next-line no-param-reassign
  recv.onmessageerror = (e) => {
    if (streamOpts.onError) {
      streamOpts.onError(e);
    }
  };
}
