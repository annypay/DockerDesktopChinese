import { createTheme } from '@mui/material/styles';
import { memoize, merge } from 'lodash';
/**
 * Takes a number of theme layers and builds a MUI theme out of
 * them.
 *
 * To understand how this function works, you should first understand
 * the difference between a Theme and ThemeOptions in MUI. The former is
 * a complete theme object, as used in rendering, and the latter is a
 * partially specified theme. A ThemeOptions can be passed to MUI's
 * createTheme function to get a Theme object (MUI fills in any gaps
 * with sensible defaults). In practice, ThemeOptions is pretty much
 * just a DeepPartial version of Theme.
 *
 * A ThemeLayer returns a ThemeOptions specifying some subset of theming
 * options. E.g. a layer might just specify a palette, or some mixins,
 * or prop overrides for a specific MUI component. Ultimately, the
 * return values of all the layers are merged together and the resulting
 * object is passed into createTheme to get a full theme.
 *
 * ThemeLayers can optionally use a provided Theme object. This object
 * represents what would happen if we built a theme out of all the
 * preceding layers.
 *
 * I rejected two designs on the way to this one.
 *
 * The first is the closest to how theme composition typically works
 * in MUI: Each layer just takes a full Theme and returns a new Theme.
 * This sounds good at first, but it has a major flaw: By the time you
 * have a Theme, MUI has already been run over a ThemeOptions object
 * and filled it in with defaults. If you want your layer to influence
 * that theme generation process - e.g. by specifying some custom
 * breakpoints or palette options - then you're too late.
 *
 * The second solution is for each layer to take a ThemeOptions and
 * return a new ThemeOptions. This is a bit better, but still lacks
 * some kinds of expressiveness. E.g. maybe I want my layer to
 * say "A primary button's outline should be primary.light in color".
 * But what if a primary layer set primary.main but not primary.light?
 * That's something we're allowed to do (MUI derives primary.light from
 * primary.main if it's not specified), but still, the ThemeOptions my
 * layer receives won't have a primary.light color on it. We won't know
 * until createTheme runs what primary.light will actually be, which
 * in this model won't happen until AFTER my layer has provided its
 * theming options.
 *
 * (N.B. this particular example was more persuasive when MUI pretty much
 * restricted you to color literals when theming any color property, but
 * the general point stands)
 */
export function composeThemeOptionsFromLayers(layers) {
    return layers.reduce((previousOptions, currentLayer) => {
        const currentOptions = currentLayer(memoize(() => createTheme(previousOptions)));
        return merge(previousOptions, currentOptions);
    }, {});
}
//# sourceMappingURL=composeThemeOptionsFromLayers.js.map