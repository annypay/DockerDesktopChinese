import {
  composeThemeOptionsFromLayers,
  ThemeLayer,
} from './composeThemeOptionsFromLayers';

describe('composeThemeOptionsFromLayers', () => {
  it('should return default MUI theme if given no layers', () => {
    expectConversion([], {});
  });

  it('should apply independent layers', () => {
    expectConversion(
      [
        () => ({ palette: { text: { primary: '#abcdef' } } }),
        () => ({ palette: { text: { secondary: '#123456' } } }),
      ],
      {
        palette: { text: { primary: '#abcdef', secondary: '#123456' } },
      },
    );
  });

  it('should give precedence to later layers', () => {
    expectConversion(
      [
        () => ({ palette: { text: { primary: '#abcdef' } } }),
        () => ({ palette: { text: { primary: '#123456' } } }),
      ],
      {
        palette: { text: { primary: '#123456' } },
      },
    );
  });

  it('should allow layers to read from theme properties indirectly controlled by previous layers', () => {
    expectConversion(
      [
        () => ({ palette: { primary: { main: '#ff0000' } } }),
        (getTheme) => ({
          palette: { text: { primary: getTheme().palette.primary.light } },
        }),
      ],
      {
        palette: {
          primary: { main: '#ff0000' },
          // this is the color that MUI automatically derives
          // as a light version of the primary color
          text: { primary: 'rgb(255, 51, 51)' },
        },
      },
    );
  });
});

function expectConversion(layers: ThemeLayer[], expectedTheme: Theme) {
  // basic toEqual deep object comparison doesn't work too well here, since the
  // theme contains functions. Hence, stringify.
  expect(JSON.stringify(composeThemeOptionsFromLayers(layers))).toEqual(
    JSON.stringify(expectedTheme),
  );
}
