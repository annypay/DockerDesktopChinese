import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import { useGridApiEventHandler, GridEvents, gridRowIdsSelector, gridRowTreeSelector, gridFilteredDescendantCountLookupSelector, useFirstRender } from '@mui/x-data-grid';
import { useGridRegisterSortingMethod, useGridRegisterFilteringMethod } from '@mui/x-data-grid/internals';
import { buildRowTree } from '../../../utils/tree/buildRowTree';
import { sortRowTree } from '../../../utils/tree/sortRowTree';
import { filterRowTreeFromTreeData } from './gridTreeDataUtils';
export var TREE_DATA_GROUPING_NAME = 'tree-data';
/**
 * Only available in DataGridPro
 * @requires useGridPreProcessing (method)
 * @requires useGridRowGroupsPreProcessing (method)
 */

export var useGridTreeData = function useGridTreeData(apiRef, props) {
  /**
   * ROW GROUPING
   */
  var updateRowGrouping = React.useCallback(function () {
    if (!props.treeData) {
      return apiRef.current.unstable_registerRowGroupsBuilder('treeData', null);
    }

    var groupRows = function groupRows(params) {
      if (!props.getTreeDataPath) {
        throw new Error('MUI: No getTreeDataPath given.');
      }

      var rows = params.ids.map(function (rowId) {
        return {
          id: rowId,
          path: props.getTreeDataPath(params.idRowsLookup[rowId]).map(function (key) {
            return {
              key: key,
              field: null
            };
          })
        };
      }).sort(function (a, b) {
        return a.path.length - b.path.length;
      });
      return buildRowTree(_extends({
        rows: rows
      }, params, {
        defaultGroupingExpansionDepth: props.defaultGroupingExpansionDepth,
        isGroupExpandedByDefault: props.isGroupExpandedByDefault,
        groupingName: TREE_DATA_GROUPING_NAME,
        onDuplicatePath: function onDuplicatePath(firstId, secondId, path) {
          throw new Error(['MUI: The path returned by `getTreeDataPath` should be unique.', "The rows with id #".concat(firstId, " and #").concat(secondId, " have the same."), "Path: ".concat(JSON.stringify(path.map(function (step) {
            return step.key;
          })), ".")].join('\n'));
        }
      }));
    };

    return apiRef.current.unstable_registerRowGroupsBuilder('treeData', groupRows);
  }, [apiRef, props.getTreeDataPath, props.treeData, props.defaultGroupingExpansionDepth, props.isGroupExpandedByDefault]);
  useFirstRender(function () {
    updateRowGrouping();
  });
  var isFirstRender = React.useRef(true);
  React.useEffect(function () {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    updateRowGrouping();
  }, [updateRowGrouping]);
  /**
   * PRE-PROCESSING
   */

  var filteringMethod = React.useCallback(function (params) {
    var rowTree = gridRowTreeSelector(apiRef);
    return filterRowTreeFromTreeData({
      rowTree: rowTree,
      isRowMatchingFilters: params.isRowMatchingFilters,
      disableChildrenFiltering: props.disableChildrenFiltering
    });
  }, [apiRef, props.disableChildrenFiltering]);
  var sortingMethod = React.useCallback(function (params) {
    var rowTree = gridRowTreeSelector(apiRef);
    var rowIds = gridRowIdsSelector(apiRef);
    return sortRowTree({
      rowTree: rowTree,
      rowIds: rowIds,
      sortRowList: params.sortRowList,
      disableChildrenSorting: props.disableChildrenSorting
    });
  }, [apiRef, props.disableChildrenSorting]);
  useGridRegisterFilteringMethod(apiRef, TREE_DATA_GROUPING_NAME, filteringMethod);
  useGridRegisterSortingMethod(apiRef, TREE_DATA_GROUPING_NAME, sortingMethod);
  /**
   * EVENTS
   */

  var handleCellKeyDown = React.useCallback(function (params, event) {
    var cellParams = apiRef.current.getCellParams(params.id, params.field);

    if (cellParams.colDef.type === 'treeDataGroup' && event.key === ' ' && !event.shiftKey) {
      var _gridFilteredDescenda;

      event.stopPropagation();
      event.preventDefault();
      var filteredDescendantCount = (_gridFilteredDescenda = gridFilteredDescendantCountLookupSelector(apiRef)[params.id]) != null ? _gridFilteredDescenda : 0;

      if (filteredDescendantCount === 0) {
        return;
      }

      apiRef.current.setRowChildrenExpansion(params.id, !params.rowNode.childrenExpanded);
    }
  }, [apiRef]);
  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, handleCellKeyDown);
};