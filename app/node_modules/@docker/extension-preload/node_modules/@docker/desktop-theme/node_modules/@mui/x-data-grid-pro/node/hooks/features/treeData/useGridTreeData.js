"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGridTreeData = exports.TREE_DATA_GROUPING_NAME = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _xDataGrid = require("@mui/x-data-grid");

var _internals = require("@mui/x-data-grid/internals");

var _buildRowTree = require("../../../utils/tree/buildRowTree");

var _sortRowTree = require("../../../utils/tree/sortRowTree");

var _gridTreeDataUtils = require("./gridTreeDataUtils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const TREE_DATA_GROUPING_NAME = 'tree-data';
/**
 * Only available in DataGridPro
 * @requires useGridPreProcessing (method)
 * @requires useGridRowGroupsPreProcessing (method)
 */

exports.TREE_DATA_GROUPING_NAME = TREE_DATA_GROUPING_NAME;

const useGridTreeData = (apiRef, props) => {
  /**
   * ROW GROUPING
   */
  const updateRowGrouping = React.useCallback(() => {
    if (!props.treeData) {
      return apiRef.current.unstable_registerRowGroupsBuilder('treeData', null);
    }

    const groupRows = params => {
      if (!props.getTreeDataPath) {
        throw new Error('MUI: No getTreeDataPath given.');
      }

      const rows = params.ids.map(rowId => ({
        id: rowId,
        path: props.getTreeDataPath(params.idRowsLookup[rowId]).map(key => ({
          key,
          field: null
        }))
      })).sort((a, b) => a.path.length - b.path.length);
      return (0, _buildRowTree.buildRowTree)((0, _extends2.default)({
        rows
      }, params, {
        defaultGroupingExpansionDepth: props.defaultGroupingExpansionDepth,
        isGroupExpandedByDefault: props.isGroupExpandedByDefault,
        groupingName: TREE_DATA_GROUPING_NAME,
        onDuplicatePath: (firstId, secondId, path) => {
          throw new Error(['MUI: The path returned by `getTreeDataPath` should be unique.', `The rows with id #${firstId} and #${secondId} have the same.`, `Path: ${JSON.stringify(path.map(step => step.key))}.`].join('\n'));
        }
      }));
    };

    return apiRef.current.unstable_registerRowGroupsBuilder('treeData', groupRows);
  }, [apiRef, props.getTreeDataPath, props.treeData, props.defaultGroupingExpansionDepth, props.isGroupExpandedByDefault]);
  (0, _xDataGrid.useFirstRender)(() => {
    updateRowGrouping();
  });
  const isFirstRender = React.useRef(true);
  React.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    updateRowGrouping();
  }, [updateRowGrouping]);
  /**
   * PRE-PROCESSING
   */

  const filteringMethod = React.useCallback(params => {
    const rowTree = (0, _xDataGrid.gridRowTreeSelector)(apiRef);
    return (0, _gridTreeDataUtils.filterRowTreeFromTreeData)({
      rowTree,
      isRowMatchingFilters: params.isRowMatchingFilters,
      disableChildrenFiltering: props.disableChildrenFiltering
    });
  }, [apiRef, props.disableChildrenFiltering]);
  const sortingMethod = React.useCallback(params => {
    const rowTree = (0, _xDataGrid.gridRowTreeSelector)(apiRef);
    const rowIds = (0, _xDataGrid.gridRowIdsSelector)(apiRef);
    return (0, _sortRowTree.sortRowTree)({
      rowTree,
      rowIds,
      sortRowList: params.sortRowList,
      disableChildrenSorting: props.disableChildrenSorting
    });
  }, [apiRef, props.disableChildrenSorting]);
  (0, _internals.useGridRegisterFilteringMethod)(apiRef, TREE_DATA_GROUPING_NAME, filteringMethod);
  (0, _internals.useGridRegisterSortingMethod)(apiRef, TREE_DATA_GROUPING_NAME, sortingMethod);
  /**
   * EVENTS
   */

  const handleCellKeyDown = React.useCallback((params, event) => {
    const cellParams = apiRef.current.getCellParams(params.id, params.field);

    if (cellParams.colDef.type === 'treeDataGroup' && event.key === ' ' && !event.shiftKey) {
      var _gridFilteredDescenda;

      event.stopPropagation();
      event.preventDefault();
      const filteredDescendantCount = (_gridFilteredDescenda = (0, _xDataGrid.gridFilteredDescendantCountLookupSelector)(apiRef)[params.id]) != null ? _gridFilteredDescenda : 0;

      if (filteredDescendantCount === 0) {
        return;
      }

      apiRef.current.setRowChildrenExpansion(params.id, !params.rowNode.childrenExpanded);
    }
  }, [apiRef]);
  (0, _xDataGrid.useGridApiEventHandler)(apiRef, _xDataGrid.GridEvents.cellKeyDown, handleCellKeyDown);
};

exports.useGridTreeData = useGridTreeData;