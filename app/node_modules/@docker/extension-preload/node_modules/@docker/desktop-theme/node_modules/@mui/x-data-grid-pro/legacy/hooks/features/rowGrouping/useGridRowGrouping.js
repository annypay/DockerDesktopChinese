import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import Divider from '@mui/material/Divider';
import { GridEvents, gridRowIdsSelector, gridRowTreeSelector, useGridApiEventHandler, useGridApiMethod, gridColumnLookupSelector, gridFilteredDescendantCountLookupSelector, useFirstRender } from '@mui/x-data-grid';
import { useGridRegisterPreProcessor, useGridRegisterSortingMethod, useGridRegisterFilteringMethod, isDeepEqual } from '@mui/x-data-grid/internals';
import { buildRowTree } from '../../../utils/tree/buildRowTree';
import { gridRowGroupingModelSelector, gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';
import { filterRowTreeFromGroupingColumns, getRowGroupingFieldFromGroupingCriteria, GROUPING_COLUMNS_FEATURE_NAME, isGroupingColumn, mergeStateWithRowGroupingModel } from './gridRowGroupingUtils';
import { sortRowTree } from '../../../utils/tree/sortRowTree';
import { GridRowGroupableColumnMenuItems } from '../../../components/GridRowGroupableColumnMenuItems';
import { GridRowGroupingColumnMenuItems } from '../../../components/GridRowGroupingColumnMenuItems';
import { jsx as _jsx } from "react/jsx-runtime";
export var rowGroupingStateInitializer = function rowGroupingStateInitializer(state, props) {
  var _ref, _props$rowGroupingMod, _props$initialState, _props$initialState$r;

  return _extends({}, state, {
    rowGrouping: {
      model: (_ref = (_props$rowGroupingMod = props.rowGroupingModel) != null ? _props$rowGroupingMod : (_props$initialState = props.initialState) == null ? void 0 : (_props$initialState$r = _props$initialState.rowGrouping) == null ? void 0 : _props$initialState$r.model) != null ? _ref : []
    }
  });
};
/**
 * Only available in DataGridPro
 * @requires useGridColumns (state, method) - can be after, async only
 * @requires useGridRows (state, method) - can be after, async only
 * @requires useGridParamsApi (method) - can be after, async only
 * TODO: Move the the Premium plan once available and remove the `experimentalFeatures.rowGrouping` flag
 */

export var useGridRowGrouping = function useGridRowGrouping(apiRef, props) {
  apiRef.current.unstable_updateControlState({
    stateId: 'rowGrouping',
    propModel: props.rowGroupingModel,
    propOnChange: props.onRowGroupingModelChange,
    stateSelector: gridRowGroupingModelSelector,
    changeEvent: GridEvents.rowGroupingModelChange
  });
  /**
   * ROW GROUPING
   */
  // Tracks the model on the last pre-processing to check if we need to re-build the grouping columns when the grid upserts a column.

  var sanitizedModelOnLastRowPreProcessing = React.useRef([]);
  var updateRowGrouping = React.useCallback(function () {
    var groupRows = function groupRows(params) {
      var rowGroupingModel = gridRowGroupingSanitizedModelSelector(apiRef);
      var columnsLookup = gridColumnLookupSelector(apiRef);
      sanitizedModelOnLastRowPreProcessing.current = rowGroupingModel;

      if (props.disableRowGrouping || rowGroupingModel.length === 0) {
        return null;
      }

      var distinctValues = Object.fromEntries(rowGroupingModel.map(function (groupingField) {
        return [groupingField, {
          lookup: {},
          list: []
        }];
      }));

      var getCellGroupingCriteria = function getCellGroupingCriteria(_ref2) {
        var row = _ref2.row,
            id = _ref2.id,
            colDef = _ref2.colDef;
        var key;

        if (colDef.groupingValueGetter) {
          var groupingValueGetterParams = {
            colDef: colDef,
            field: colDef.field,
            value: row[colDef.field],
            id: id,
            row: row,
            rowNode: {
              isAutoGenerated: false,
              id: id
            }
          };
          key = colDef.groupingValueGetter(groupingValueGetterParams);
        } else {
          key = row[colDef.field];
        }

        return {
          key: key,
          field: colDef.field
        };
      };

      params.ids.forEach(function (rowId) {
        var row = params.idRowsLookup[rowId];
        rowGroupingModel.forEach(function (groupingCriteria) {
          var _getCellGroupingCrite = getCellGroupingCriteria({
            row: row,
            id: rowId,
            colDef: columnsLookup[groupingCriteria]
          }),
              key = _getCellGroupingCrite.key;

          var groupingFieldsDistinctKeys = distinctValues[groupingCriteria];

          if (key != null && !groupingFieldsDistinctKeys.lookup[key.toString()]) {
            groupingFieldsDistinctKeys.lookup[key.toString()] = true;
            groupingFieldsDistinctKeys.list.push(key);
          }
        });
      });
      var rows = params.ids.map(function (rowId) {
        var row = params.idRowsLookup[rowId];
        var parentPath = rowGroupingModel.map(function (groupingField) {
          return getCellGroupingCriteria({
            row: row,
            id: rowId,
            colDef: columnsLookup[groupingField]
          });
        }).filter(function (cell) {
          return cell.key != null;
        });
        var leafGroupingCriteria = {
          key: rowId.toString(),
          field: null
        };
        return {
          path: [].concat(_toConsumableArray(parentPath), [leafGroupingCriteria]),
          id: rowId
        };
      });
      return buildRowTree(_extends({}, params, {
        rows: rows,
        defaultGroupingExpansionDepth: props.defaultGroupingExpansionDepth,
        isGroupExpandedByDefault: props.isGroupExpandedByDefault,
        groupingName: GROUPING_COLUMNS_FEATURE_NAME
      }));
    };

    return apiRef.current.unstable_registerRowGroupsBuilder('rowGrouping', groupRows);
  }, [apiRef, props.defaultGroupingExpansionDepth, props.isGroupExpandedByDefault, props.disableRowGrouping]);
  useFirstRender(function () {
    updateRowGrouping();
  });
  var isFirstRender = React.useRef(true);
  React.useEffect(function () {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return function () {};
    }

    return updateRowGrouping();
  }, [updateRowGrouping]);
  /**
   * PRE-PROCESSING
   */

  var addColumnMenuButtons = React.useCallback(function (initialValue, columns) {
    if (props.disableRowGrouping) {
      return initialValue;
    }

    var menuItems;

    if (isGroupingColumn(columns.field)) {
      menuItems = /*#__PURE__*/_jsx(GridRowGroupingColumnMenuItems, {});
    } else if (columns.groupable) {
      menuItems = /*#__PURE__*/_jsx(GridRowGroupableColumnMenuItems, {});
    } else {
      menuItems = null;
    }

    if (menuItems == null) {
      return initialValue;
    }

    return [].concat(_toConsumableArray(initialValue), [/*#__PURE__*/_jsx(Divider, {}), menuItems]);
  }, [props.disableRowGrouping]);
  var filteringMethod = React.useCallback(function (params) {
    var rowTree = gridRowTreeSelector(apiRef);
    return filterRowTreeFromGroupingColumns({
      rowTree: rowTree,
      isRowMatchingFilters: params.isRowMatchingFilters
    });
  }, [apiRef]);
  var sortingMethod = React.useCallback(function (params) {
    var rowTree = gridRowTreeSelector(apiRef);
    var rowIds = gridRowIdsSelector(apiRef);
    return sortRowTree({
      rowTree: rowTree,
      rowIds: rowIds,
      sortRowList: params.sortRowList,
      disableChildrenSorting: false
    });
  }, [apiRef]);
  useGridRegisterPreProcessor(apiRef, 'columnMenu', addColumnMenuButtons);
  useGridRegisterFilteringMethod(apiRef, GROUPING_COLUMNS_FEATURE_NAME, filteringMethod);
  useGridRegisterSortingMethod(apiRef, GROUPING_COLUMNS_FEATURE_NAME, sortingMethod);
  /**
   * API METHODS
   */

  var setRowGroupingModel = React.useCallback(function (model) {
    var currentModel = gridRowGroupingModelSelector(apiRef);

    if (currentModel !== model) {
      apiRef.current.setState(mergeStateWithRowGroupingModel(model));
      updateRowGrouping();
      apiRef.current.forceUpdate();
    }
  }, [apiRef, updateRowGrouping]);
  var addRowGroupingCriteria = React.useCallback(function (field, groupingIndex) {
    var currentModel = gridRowGroupingModelSelector(apiRef);

    if (currentModel.includes(field)) {
      return;
    }

    var cleanGroupingIndex = groupingIndex != null ? groupingIndex : currentModel.length;
    var updatedModel = [].concat(_toConsumableArray(currentModel.slice(0, cleanGroupingIndex)), [field], _toConsumableArray(currentModel.slice(cleanGroupingIndex)));
    apiRef.current.setRowGroupingModel(updatedModel);
  }, [apiRef]);
  var removeRowGroupingCriteria = React.useCallback(function (field) {
    var currentModel = gridRowGroupingModelSelector(apiRef);

    if (!currentModel.includes(field)) {
      return;
    }

    apiRef.current.setRowGroupingModel(currentModel.filter(function (el) {
      return el !== field;
    }));
  }, [apiRef]);
  var setRowGroupingCriteriaIndex = React.useCallback(function (field, targetIndex) {
    var currentModel = gridRowGroupingModelSelector(apiRef);
    var currentTargetIndex = currentModel.indexOf(field);

    if (currentTargetIndex === -1) {
      return;
    }

    var updatedModel = _toConsumableArray(currentModel);

    updatedModel.splice(targetIndex, 0, updatedModel.splice(currentTargetIndex, 1)[0]);
    apiRef.current.setRowGroupingModel(updatedModel);
  }, [apiRef]);
  var rowGroupingApi = {
    setRowGroupingModel: setRowGroupingModel,
    addRowGroupingCriteria: addRowGroupingCriteria,
    removeRowGroupingCriteria: removeRowGroupingCriteria,
    setRowGroupingCriteriaIndex: setRowGroupingCriteriaIndex
  };
  useGridApiMethod(apiRef, rowGroupingApi, 'GridRowGroupingApi');
  /**
   * PRE-PROCESSING
   */

  var stateExportPreProcessing = React.useCallback(function (prevState) {
    if (props.disableRowGrouping) {
      return prevState;
    }

    var rowGroupingModelToExport = gridRowGroupingModelSelector(apiRef);

    if (rowGroupingModelToExport.length === 0) {
      return prevState;
    }

    return _extends({}, prevState, {
      rowGrouping: {
        model: rowGroupingModelToExport
      }
    });
  }, [apiRef, props.disableRowGrouping]);
  var stateRestorePreProcessing = React.useCallback(function (params, context) {
    var _context$stateToResto;

    if (props.disableRowGrouping) {
      return params;
    }

    var rowGroupingModel = (_context$stateToResto = context.stateToRestore.rowGrouping) == null ? void 0 : _context$stateToResto.model;

    if (rowGroupingModel != null) {
      apiRef.current.setState(mergeStateWithRowGroupingModel(rowGroupingModel));
    }

    return params;
  }, [apiRef, props.disableRowGrouping]);
  useGridRegisterPreProcessor(apiRef, 'exportState', stateExportPreProcessing);
  useGridRegisterPreProcessor(apiRef, 'restoreState', stateRestorePreProcessing);
  /**
   * EVENTS
   */

  var handleCellKeyDown = React.useCallback(function (params, event) {
    var cellParams = apiRef.current.getCellParams(params.id, params.field);

    if (isGroupingColumn(cellParams.field) && event.key === ' ' && !event.shiftKey) {
      var _gridFilteredDescenda;

      event.stopPropagation();
      event.preventDefault();
      var filteredDescendantCount = (_gridFilteredDescenda = gridFilteredDescendantCountLookupSelector(apiRef)[params.id]) != null ? _gridFilteredDescenda : 0;
      var isOnGroupingCell = props.rowGroupingColumnMode === 'single' || getRowGroupingFieldFromGroupingCriteria(params.rowNode.groupingField) === params.field;

      if (!isOnGroupingCell || filteredDescendantCount === 0) {
        return;
      }

      apiRef.current.setRowChildrenExpansion(params.id, !params.rowNode.childrenExpanded);
    }
  }, [apiRef, props.rowGroupingColumnMode]);
  var checkGroupingColumnsModelDiff = React.useCallback(function () {
    var rowGroupingModel = gridRowGroupingSanitizedModelSelector(apiRef);
    var lastGroupingColumnsModelApplied = sanitizedModelOnLastRowPreProcessing.current;

    if (!isDeepEqual(lastGroupingColumnsModelApplied, rowGroupingModel)) {
      sanitizedModelOnLastRowPreProcessing.current = rowGroupingModel; // Refresh the column pre-processing

      apiRef.current.updateColumns([]);
      updateRowGrouping();
    }
  }, [apiRef, updateRowGrouping]);
  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, handleCellKeyDown);
  useGridApiEventHandler(apiRef, GridEvents.columnsChange, checkGroupingColumnsModelDiff);
  useGridApiEventHandler(apiRef, GridEvents.rowGroupingModelChange, checkGroupingColumnsModelDiff);
  /**
   * EFFECTS
   */

  React.useEffect(function () {
    if (props.rowGroupingModel !== undefined) {
      apiRef.current.setRowGroupingModel(props.rowGroupingModel);
    }
  }, [apiRef, props.rowGroupingModel]);
};