import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["hideDescendantCount"];
import * as React from 'react';
import { useGridRegisterPreProcessor } from '@mui/x-data-grid/internals';
import { GRID_TREE_DATA_GROUPING_COL_DEF, GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES } from './gridTreeDataGroupColDef';
import { TREE_DATA_GROUPING_NAME } from './useGridTreeData';
import { GridTreeDataGroupingCell } from '../../../components';
import { jsx as _jsx } from "react/jsx-runtime";
export var useGridTreeDataPreProcessors = function useGridTreeDataPreProcessors(apiRef, props) {
  var getGroupingColDef = React.useCallback(function () {
    var _colDefOverride;

    var groupingColDefProp = props.groupingColDef;
    var colDefOverride;

    if (typeof groupingColDefProp === 'function') {
      var params = {
        groupingName: TREE_DATA_GROUPING_NAME,
        fields: []
      };
      colDefOverride = groupingColDefProp(params);
    } else {
      colDefOverride = groupingColDefProp;
    }

    var _ref = (_colDefOverride = colDefOverride) != null ? _colDefOverride : {},
        hideDescendantCount = _ref.hideDescendantCount,
        colDefOverrideProperties = _objectWithoutProperties(_ref, _excluded);

    var commonProperties = _extends({}, GRID_TREE_DATA_GROUPING_COL_DEF, {
      renderCell: function renderCell(params) {
        return /*#__PURE__*/_jsx(GridTreeDataGroupingCell, _extends({}, params, {
          hideDescendantCount: hideDescendantCount
        }));
      },
      headerName: apiRef.current.getLocaleText('treeDataGroupingHeaderName')
    });

    return _extends({}, commonProperties, colDefOverrideProperties, GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES);
  }, [apiRef, props.groupingColDef]);
  var updateGroupingColumn = React.useCallback(function (columnsState) {
    var groupingColDefField = GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES.field;
    var shouldHaveGroupingColumn = props.treeData;
    var prevGroupingColumn = columnsState.lookup[groupingColDefField];

    if (shouldHaveGroupingColumn) {
      var newGroupingColumn = getGroupingColDef();

      if (prevGroupingColumn) {
        newGroupingColumn.width = prevGroupingColumn.width;
        newGroupingColumn.flex = prevGroupingColumn.flex;
      }

      columnsState.lookup[groupingColDefField] = newGroupingColumn;

      if (prevGroupingColumn == null) {
        var index = columnsState.all[0] === '__check__' ? 1 : 0;
        columnsState.all = [].concat(_toConsumableArray(columnsState.all.slice(0, index)), [groupingColDefField], _toConsumableArray(columnsState.all.slice(index)));
      }
    } else if (!shouldHaveGroupingColumn && prevGroupingColumn) {
      delete columnsState.lookup[groupingColDefField];
      columnsState.all = columnsState.all.filter(function (field) {
        return field !== groupingColDefField;
      });
    }

    return columnsState;
  }, [props.treeData, getGroupingColDef]);
  useGridRegisterPreProcessor(apiRef, 'hydrateColumns', updateGroupingColumn);
};