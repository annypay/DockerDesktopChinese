import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
const _excluded = ["hideDescendantCount"];
import * as React from 'react';
import { useGridRegisterPreProcessor } from '@mui/x-data-grid/internals';
import { GRID_TREE_DATA_GROUPING_COL_DEF, GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES } from './gridTreeDataGroupColDef';
import { TREE_DATA_GROUPING_NAME } from './useGridTreeData';
import { GridTreeDataGroupingCell } from '../../../components';
import { jsx as _jsx } from "react/jsx-runtime";
export const useGridTreeDataPreProcessors = (apiRef, props) => {
  const getGroupingColDef = React.useCallback(() => {
    var _colDefOverride;

    const groupingColDefProp = props.groupingColDef;
    let colDefOverride;

    if (typeof groupingColDefProp === 'function') {
      const params = {
        groupingName: TREE_DATA_GROUPING_NAME,
        fields: []
      };
      colDefOverride = groupingColDefProp(params);
    } else {
      colDefOverride = groupingColDefProp;
    }

    const _ref = (_colDefOverride = colDefOverride) != null ? _colDefOverride : {},
          {
      hideDescendantCount
    } = _ref,
          colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);

    const commonProperties = _extends({}, GRID_TREE_DATA_GROUPING_COL_DEF, {
      renderCell: params => /*#__PURE__*/_jsx(GridTreeDataGroupingCell, _extends({}, params, {
        hideDescendantCount: hideDescendantCount
      })),
      headerName: apiRef.current.getLocaleText('treeDataGroupingHeaderName')
    });

    return _extends({}, commonProperties, colDefOverrideProperties, GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES);
  }, [apiRef, props.groupingColDef]);
  const updateGroupingColumn = React.useCallback(columnsState => {
    const groupingColDefField = GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES.field;
    const shouldHaveGroupingColumn = props.treeData;
    const prevGroupingColumn = columnsState.lookup[groupingColDefField];

    if (shouldHaveGroupingColumn) {
      const newGroupingColumn = getGroupingColDef();

      if (prevGroupingColumn) {
        newGroupingColumn.width = prevGroupingColumn.width;
        newGroupingColumn.flex = prevGroupingColumn.flex;
      }

      columnsState.lookup[groupingColDefField] = newGroupingColumn;

      if (prevGroupingColumn == null) {
        const index = columnsState.all[0] === '__check__' ? 1 : 0;
        columnsState.all = [...columnsState.all.slice(0, index), groupingColDefField, ...columnsState.all.slice(index)];
      }
    } else if (!shouldHaveGroupingColumn && prevGroupingColumn) {
      delete columnsState.lookup[groupingColDefField];
      columnsState.all = columnsState.all.filter(field => field !== groupingColDefField);
    }

    return columnsState;
  }, [props.treeData, getGroupingColDef]);
  useGridRegisterPreProcessor(apiRef, 'hydrateColumns', updateGroupingColumn);
};